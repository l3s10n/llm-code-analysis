"""
Utility functions for the path verification module.
Provides helper functions for loading paths, printing progress, and formatting results.
"""

import json
import os
from typing import List, Optional

from .models import (
    PotentialPath,
    PathNode,
    DataflowInfo,
    FilterLogic,
    NodeDataflowRecord,
    VerificationResult
)


def load_potential_paths(json_path: str) -> List[PotentialPath]:
    """
    Load potential vulnerability paths from a JSON file.

    Args:
        json_path: Path to the JSON file generated by path_explore

    Returns:
        List of PotentialPath objects

    Raises:
        FileNotFoundError: If the JSON file does not exist
        json.JSONDecodeError: If the file is not valid JSON
    """
    with open(json_path, 'r', encoding='utf-8') as f:
        data = json.load(f)

    return [PotentialPath.from_dict(item) for item in data]


def print_separator(char: str = "-", length: int = 60) -> None:
    """
    Print a separator line.

    Args:
        char: Character to use for the separator
        length: Length of the separator line
    """
    print(char * length)


def print_stage_header(stage: str, path_display: str) -> None:
    """
    Print a formatted header for a verification stage.

    Args:
        stage: Name of the current stage
        path_display: Display string for the current path
    """
    print()
    print_separator("=")
    print(f"[Stage: {stage}]")
    print(f"Call Chain: {path_display}")
    print_separator("=")


def print_call_chain(path: PotentialPath, highlight_index: Optional[int] = None) -> None:
    """
    Print the call chain with optional node highlighting.

    Args:
        path: PotentialPath to display
        highlight_index: Index of the node to highlight (None for no highlight)
    """
    print("\nCall Chain:")
    for i, node in enumerate(path.path):
        prefix = ">>> " if i == highlight_index else "    "
        print(f"  {prefix}[{i}] {node.name} ({node.file})")
    print(f"      -> sink: {path.sink_expression}")


def print_dataflow_analysis(records: List[NodeDataflowRecord]) -> None:
    """
    Print dataflow analysis results in a formatted manner.

    Args:
        records: List of NodeDataflowRecord to display
    """
    print("\n[Dataflow Analysis Results]")
    print_separator("-")

    for record in records:
        print(f"\n  Node [{record.node_index}]: {record.node_name}")
        info = record.dataflow_info
        if info.parameters:
            print(f"    Parameters: {', '.join(info.parameters)}")
        if info.member_variables:
            print(f"    Member Variables: {', '.join(info.member_variables)}")
        if info.is_empty():
            print("    (No dataflow to sink)")

    print()


def print_filter_analysis(logics: List[FilterLogic]) -> None:
    """
    Print filter analysis results in a formatted manner.

    Args:
        logics: List of FilterLogic to display
    """
    print("\n[Filter Analysis Results]")
    print_separator("-")

    if not logics:
        print("\n  No filtering logic found that could prevent exploitation.")
        return

    for i, logic in enumerate(logics, 1):
        print(f"\n  Filter #{i}:")
        print(f"    Dataflow: {logic.dataflow}")
        print(f"    Description: {logic.description}")
        location = logic.file_path
        if logic.line_range:
            location += f":{logic.line_range[0]}-{logic.line_range[1]}"
        print(f"    Location: {location}")

    print()


def print_final_result(result: VerificationResult) -> None:
    """
    Print the final verification result in a formatted manner.

    Args:
        result: VerificationResult to display
    """
    print("\n" + "=" * 60)
    print("[Final Verification Result]")
    print("=" * 60)

    # Vulnerability status
    status = "VULNERABLE" if result.is_vulnerable else "NOT VULNERABLE"
    status_color = "\033[91m" if result.is_vulnerable else "\033[92m"
    reset_color = "\033[0m"

    print(f"\n  Status: {status_color}{status}{reset_color}")
    print(f"  Confidence: {result.confidence}")
    print(f"  Vulnerability Type: {result.vulnerability_type}")
    print(f"  Sink: {result.sink_expression}")

    # Summary
    if result.summary:
        print(f"\n  Summary: {result.summary}")

    # Dataflow summary
    if result.dataflow_records:
        print("\n  Dataflow Summary:")
        for record in result.dataflow_records:
            df = record.dataflow_info
            params = ", ".join(df.parameters) if df.parameters else "None"
            members = ", ".join(df.member_variables) if df.member_variables else "None"
            print(f"    [{record.node_name}]: params={params}, members={members}")

    # Filters summary
    if result.filter_logics:
        print(f"\n  Filters Found: {len(result.filter_logics)}")
        for logic in result.filter_logics:
            print(f"    - {logic.description[:50]}..." if len(logic.description) > 50
                  else f"    - {logic.description}")

    print("\n" + "=" * 60)


def print_verification_summary(results: List[VerificationResult]) -> None:
    """
    Print a summary of all verification results.

    Args:
        results: List of VerificationResult to summarize
    """
    print("\n" + "=" * 60)
    print("[Verification Summary]")
    print("=" * 60)

    total = len(results)
    vulnerable = sum(1 for r in results if r.is_vulnerable)
    not_vulnerable = total - vulnerable

    print(f"\n  Total Paths Analyzed: {total}")
    print(f"  Vulnerable: {vulnerable}")
    print(f"  Not Vulnerable: {not_vulnerable}")

    # Breakdown by type
    path_traversal = sum(1 for r in results if r.vulnerability_type == "PathTraversal")
    command_injection = sum(1 for r in results if r.vulnerability_type == "CommandInjection")
    code_injection = sum(1 for r in results if r.vulnerability_type == "CodeInjection")
    sql_injection = sum(1 for r in results if r.vulnerability_type == "SQLInjection")

    print(f"\n  By Vulnerability Type:")
    print(f"    Path Traversal: {path_traversal}")
    print(f"    Command Injection: {command_injection}")
    print(f"    Code Injection: {code_injection}")
    print(f"    SQL Injection: {sql_injection}")

    # List vulnerable paths
    if vulnerable > 0:
        print("\n  Vulnerable Paths:")
        for r in results:
            if r.is_vulnerable:
                # Build call chain display from path
                names = [node.name for node in r.path]
                names.append("sink")
                call_chain = " -> ".join(names)
                print(f"    - {call_chain} ({r.vulnerability_type})")

    print("\n" + "=" * 60)


def get_short_filename(file_path: str) -> str:
    """
    Get the short filename (without path) from a full file path.

    Args:
        file_path: Full file path

    Returns:
        Just the filename portion
    """
    return os.path.basename(file_path) if file_path else "unknown"


def format_node_for_display(node: PathNode, index: int) -> str:
    """
    Format a path node for display.

    Args:
        node: PathNode to format
        index: Index of the node in the path

    Returns:
        Formatted string like "[0] functionName (filename.java)"
    """
    short_file = get_short_filename(node.file)
    return f"[{index}] {node.name} ({short_file})"
